import requests
import re
import json
import time
import math

# é«˜å¾·åœ°å›¾APIé…ç½®
AMAP_API_KEY = ""  # å°†åœ¨travel.pyä¸­è®¾ç½®

def set_amap_api_key(api_key):
    global AMAP_API_KEY
    AMAP_API_KEY = api_key
    print(f"[AMAP] APIå¯†é’¥å·²è®¾ç½®ä¸º: {api_key}")

def search_poi(keyword, city_name=None):
    """ä½¿ç”¨é«˜å¾·POIæœç´¢APIå°†å…³é”®è¯è½¬æ¢ä¸ºåœ°å€"""
    if not keyword.strip():
        return None
        
    # è·å–åŸå¸‚ä»£ç ï¼ˆadcodeï¼‰ï¼Œé»˜è®¤åŒ—äº¬
    city_code = "110000"  # åŒ—äº¬å¸‚åŸå¸‚ä»£ç 
    if city_name:
        # ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„åŸå¸‚ä»£ç ï¼Œè‹¥è·å–å¤±è´¥åˆ™ä½¿ç”¨é»˜è®¤
        temp_code = get_city_code_by_name(city_name)
        if temp_code:
            city_code = temp_code
    
    url = "https://restapi.amap.com/v5/place/text"
    params = {
        "key": AMAP_API_KEY,
        "keywords": keyword,
        "output": "json",
        "offset": 10,
        "extensions": "all",
        "citylimit": "true",  # ä¸¥æ ¼é™åˆ¶åŸå¸‚èŒƒå›´
        "city": city_code      # å¼ºåˆ¶æŒ‡å®šåŸå¸‚ä»£ç 
    }
    
    try:
        response = requests.get(url, params=params, timeout=5)
        data = response.json()
        print(f"POIæœç´¢å“åº”: {json.dumps(data, ensure_ascii=False, indent=2)}")  # è°ƒè¯•æ—¥å¿—
        
        if data["status"] == "1" and data["pois"]:
            # ä¼˜å…ˆé€‰æ‹©æ™¯ç‚¹ã€é£æ™¯åèƒœç­‰ç±»å‹
            poi_priorities = [
                'é£æ™¯åèƒœ', 'æ—…æ¸¸æ™¯ç‚¹', 'å…¬å›­å¹¿åœº', 'åšç‰©é¦†', 'çºªå¿µé¦†', 'æ–‡åŒ–åœºé¦†',  # ä¼˜å…ˆåŒ¹é…æ™¯ç‚¹
                'å®—æ•™åœºæ‰€', 'å¤è¿¹é—å€', 'å¨±ä¹ä¼‘é—²', 'è´­ç‰©æœåŠ¡', 'é¤é¥®æœåŠ¡',
                'å•†åŠ¡ä½å®…', 'åœ°ååœ°å€', 'äº¤é€šè®¾æ–½'
            ]
            
            best_poi = None
            best_score = 0
            
            for priority_type in poi_priorities:
                for poi in data["pois"]:
                    poi_type = poi.get("type", "")
                    if priority_type in poi_type:
                        score = calculate_poi_score(poi, priority_type, poi_priorities)
                        if score > best_score:
                            best_score = score
                            best_poi = poi
            
            if best_poi:
                address = best_poi.get("address", "")
                name = best_poi.get("name", "")
                return {
                    'address': f"{address}{name}" if name not in address else address,
                    'name': name,
                    'type': best_poi.get("type", ""),
                    'location': best_poi.get("location", ""),
                    'tel': best_poi.get("tel", ""),
                    'rating': best_poi.get("biz_ext", {}).get("rating", ""),
                    'cost': best_poi.get("biz_ext", {}).get("cost", "")
                }
            else:
                # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä¼˜å…ˆçº§POIï¼Œè¿”å›ç¬¬ä¸€ä¸ªç»“æœ
                first_poi = data["pois"][0]
                return {
                    'address': first_poi.get("address", first_poi["name"]),
                    'name': first_poi["name"],
                    'type': first_poi.get("type", ""),
                    'location': first_poi.get("location", ""),
                    'tel': first_poi.get("tel", ""),
                    'rating': first_poi.get("biz_ext", {}).get("rating", ""),
                    'cost': first_poi.get("biz_ext", {}).get("cost", "")
                }
        return None
    except Exception as e:
        print(f"POIæœç´¢å¤±è´¥: {e}")
        return None

def get_city_code_by_name(city_name):
    """æ ¹æ®åŸå¸‚åç§°è·å–åŸå¸‚ä»£ç ï¼ˆadcodeï¼‰"""
    url = "https://restapi.amap.com/v3/config/district"
    params = {
        "key": AMAP_API_KEY,
        "keywords": city_name,
        "subdistrict": "0",  # ä¸è·å–ä¸‹çº§è¡Œæ”¿åŒº
        "extensions": "base"
    }
    
    try:
        response = requests.get(url, params=params, timeout=5)
        data = response.json()
        
        if data["status"] == "1" and data["districts"]:
            # è¿”å›ç¬¬ä¸€ä¸ªåŒ¹é…çš„åŸå¸‚ä»£ç 
            return data["districts"][0]["adcode"]
        return None
    except Exception as e:
        print(f"è·å–åŸå¸‚ä»£ç å¤±è´¥: {e}")
        return None

def calculate_poi_score(poi, priority_type, poi_priorities):
    """è®¡ç®—POIçš„ç»¼åˆè¯„åˆ†"""
    base_score = len(poi_priorities) - poi_priorities.index(priority_type)
    
    # åŠ å…¥è¯„åˆ†æƒé‡
    rating = poi.get("biz_ext", {}).get("rating", "0")
    if rating and rating != "0":
        try:
            rating_score = float(rating) * 10
            base_score += rating_score
        except:
            pass
    
    # åŠ å…¥åç§°åŒ¹é…åº¦æƒé‡
    name = poi.get("name", "")
    keywords = ["æ™¯åŒº", "å…¬å›­", "åšç‰©é¦†", "å¯º", "åº™", "å±±", "æ¹–", "å¤", "æ–‡åŒ–", "å†å²"]
    for keyword in keywords:
        if keyword in name:
            base_score += 5
    
    # æ–°å¢ï¼šåç§°ä¸­åŒ…å«ç‰¹å®šæ™¯ç‚¹å…³é”®è¯æ—¶åŠ åˆ†
    name_lower = name.lower()
    key_words = ["æ•…å®«", "é¢å’Œå›­", "å¤©å®‰é—¨", "é•¿åŸ", "åœ†æ˜å›­", "å¤©å›", "é¸Ÿå·¢", "æ°´ç«‹æ–¹"]
    if any(word in name_lower for word in key_words):
        base_score += 20  # å¤§å¹…æå‡åŒ¹é…æƒé‡
    
    return base_score

def geocode_address(address_info):
    """ä½¿ç”¨é«˜å¾·åœ°å›¾APIå°†åœ°å€è½¬æ¢ä¸ºç»çº¬åº¦"""
    if isinstance(address_info, dict):
        address = address_info['address']
        # å¦‚æœå·²æœ‰ç»çº¬åº¦ä¿¡æ¯ï¼Œç›´æ¥ä½¿ç”¨
        if address_info.get('location'):
            try:
                lng, lat = address_info['location'].split(',')
                return float(lng), float(lat), address, address_info
            except:
                pass
    else:
        address = address_info
        address_info = {
            'address': address,
            'name': address,
            'type': '',
            'location': '',
            'tel': '',
            'rating': '',
            'cost': ''
        }
    
    url = "https://restapi.amap.com/v3/geocode/geo"
    params = {
        "key": AMAP_API_KEY,
        "address": address,
        "output": "json"
    }
    try:
        response = requests.get(url, params=params, timeout=5)
        data = response.json()
        if data["status"] == "1" and data["geocodes"]:
            location = data["geocodes"][0]["location"]
            lng, lat = location.split(",")
            formatted_address = data["geocodes"][0]["formatted_address"]
            return float(lng), float(lat), formatted_address, address_info
        else:
            print(f"åœ°ç†ç¼–ç å¤±è´¥ï¼Œåœ°å€: {address}, é”™è¯¯ä¿¡æ¯: {data.get('info', 'æœªçŸ¥é”™è¯¯')}")
            return None, None, f"æ— æ³•è§£æåœ°å€: {address}", address_info
    except Exception as e:
        print(f"åœ°ç†ç¼–ç é”™è¯¯: {e}ï¼Œåœ°å€: {address}")
        return None, None, f"åœ°ç†ç¼–ç é”™è¯¯: {str(e)}", address_info

def get_city_code(lng, lat):
    """æ ¹æ®ç»çº¬åº¦è·å–åŸå¸‚ä»£ç """
    url = "https://restapi.amap.com/v3/geocode/regeo"
    params = {
        "key": AMAP_API_KEY,
        "location": f"{lng},{lat}",
        "extensions": "base",
        "output": "json"
    }
    try:
        response = requests.get(url, params=params)
        data = response.json()
        if data["status"] == "1":
            return data["regeocode"]["addressComponent"]["adcode"]
    except Exception as e:
        print(f"è·å–åŸå¸‚ä»£ç å¤±è´¥: {str(e)}")
    return None

def calculate_route(start_lng, start_lat, end_lng, end_lat, transport_mode="driving"):
    """ä½¿ç”¨é«˜å¾·åœ°å›¾APIè®¡ç®—è·¯çº¿ï¼Œæ”¯æŒä¸åŒäº¤é€šæ–¹å¼"""
    # è½¬æ¢ä¸ºAPIæ”¯æŒçš„æ¨¡å¼ï¼Œæ”¯æŒä¸­æ–‡å’Œè‹±æ–‡è¾“å…¥
    mode_map = {
        "é©¾è½¦": "driving",
        "è‡ªé©¾": "driving",
        "driving": "driving",
        "å…¬äº¤": "transit",
        "å…¬å…±äº¤é€š": "transit",
        "transit": "transit",
        "æ­¥è¡Œ": "walking",
        "èµ°è·¯": "walking",
        "walking": "walking",
        "éª‘è¡Œ": "bicycling",
        "è‡ªè¡Œè½¦": "bicycling",
        "bicycling": "bicycling"
    }
    
    # è½¬æ¢ä¸ºAPIæ”¯æŒçš„æ¨¡å¼ï¼Œé»˜è®¤é©¾è½¦
    api_mode = mode_map.get(transport_mode.lower(), "driving")
    
    if api_mode == "driving":
        url = "https://restapi.amap.com/v3/direction/driving"
    elif api_mode == "transit":
        url = "https://restapi.amap.com/v3/direction/transit/integrated"
    elif api_mode == "walking":
        url = "https://restapi.amap.com/v3/direction/walking"
    elif api_mode == "bicycling":
        url = "https://restapi.amap.com/v4/direction/bicycling"
    else:
        return {"success": False, "error": f"ä¸æ”¯æŒçš„äº¤é€šæ–¹å¼: {transport_mode}"}
    
    params = {
        "key": AMAP_API_KEY,
        "origin": f"{start_lng},{start_lat}",
        "destination": f"{end_lng},{end_lat}",
        "output": "json",
        "extensions": "all"
    }
    
    if api_mode == "transit":
        city_code = get_city_code(start_lng, start_lat)
        if city_code:
            params["city"] = city_code
            params["cityd"] = get_city_code(end_lng, end_lat) or city_code
        else:
            params["city"] = "110000"  # é»˜è®¤åŒ—äº¬
            params["cityd"] = "110000"
    
    try:
        response = requests.get(url, params=params, timeout=10)
        data = response.json()
        
        if data.get("status") == "1" and "route" in data:
            if api_mode == "driving":
                path = data["route"]["paths"][0]
                polyline = path["steps"][0]["polyline"] if path["steps"] else ""
                distance = path["distance"]
                duration = path["duration"]
                tolls = path.get("tolls", "0")
                traffic_lights = path.get("traffic_lights", "0")
            elif api_mode == "transit":
                path = data["route"]["transits"][0]
                polyline = extract_transit_polyline(path)
                distance = path["distance"]
                duration = path["duration"]
                tolls = "0"
                traffic_lights = "0"
            elif api_mode == "walking":
                path = data["route"]["paths"][0]
                polyline = path["steps"][0]["polyline"] if path["steps"] else ""
                distance = path["distance"]
                duration = path["duration"]
                tolls = "0"
                traffic_lights = "0"
            elif api_mode == "bicycling":
                path = data["data"]["paths"][0]
                polyline = path["polyline"]
                distance = path["distance"]
                duration = path["duration"]
                tolls = "0"
                traffic_lights = "0"
            
            return {
                "polyline": polyline,
                "distance": distance,
                "duration": duration,
                "tolls": tolls,
                "traffic_lights": traffic_lights,
                "success": True,
                "transport_mode": api_mode
            }
        else:
            error_info = data.get("info", "æœªçŸ¥é”™è¯¯")
            print(f"è·¯çº¿è§„åˆ’å¤±è´¥ï¼Œèµ·ç‚¹: {start_lng},{start_lat}, ç»ˆç‚¹: {end_lng},{end_lat}, é”™è¯¯ä¿¡æ¯: {error_info}")
            return {"success": False, "error": f"è·¯çº¿è§„åˆ’å¤±è´¥: {error_info}"}
    except Exception as e:
        print(f"è·¯çº¿è§„åˆ’é”™è¯¯: {e}ï¼Œèµ·ç‚¹: {start_lng},{start_lat}ï¼Œç»ˆç‚¹: {end_lng},{end_lat}")
        return {"success": False, "error": f"è·¯çº¿è§„åˆ’é”™è¯¯: {str(e)}"}

def extract_transit_polyline(transit_path):
    """ä»å…¬äº¤è·¯çº¿ä¸­æå–æŠ˜çº¿æ•°æ®"""
    polylines = []
    
    for segment in transit_path.get("segments", []):
        walking = segment.get("walking")
        if walking and "polyline" in walking:
            polylines.append(walking["polyline"])
        
        bus = segment.get("bus")
        if bus:
            buslines = bus.get("buslines", [])
            for busline in buslines:
                if "polyline" in busline:
                    polylines.append(busline["polyline"])
    
    return ";".join(polylines)

def generate_route_map(locations, routes, transport_mode, show_details, optimize_route):
    """ç”Ÿæˆç¾åŒ–åçš„è·¯çº¿åœ°å›¾ï¼ŒåŒ…å«è‡ªå®šä¹‰æ ‡è®°å’Œè·¯çº¿"""
    # è¿‡æ»¤æ— æ•ˆä½ç½®
    valid_locations = []
    for loc in locations:
        if len(loc) < 4:
            print(f"æ— æ•ˆä½ç½®æ ¼å¼: {loc}")
            continue
        lng, lat, addr, info = loc
        if lng and lat:
            valid_locations.append((lng, lat, addr, info))
        else:
            print(f"æ— æ•ˆåæ ‡: {loc}")
    
    if not valid_locations:
        return "æ²¡æœ‰æœ‰æ•ˆçš„åœ°ç†åæ ‡"
    
    # è®¡ç®—ä¸­å¿ƒç‚¹å’Œç¼©æ”¾çº§åˆ«
    center_lng = sum([loc[0] for loc in valid_locations]) / len(valid_locations)
    center_lat = sum([loc[1] for loc in valid_locations]) / len(valid_locations)
    
    # è®¡ç®—æœ€å¤§è·ç¦»ç¡®å®šç¼©æ”¾çº§åˆ«
    max_distance = calculate_max_distance(valid_locations)
    zoom_level = calculate_zoom_level(max_distance)
    
    # äº¤é€šæ–¹å¼å›¾æ ‡
    transport_icons = {
        "driving": "ğŸš—",
        "transit": "ğŸšŒ", 
        "walking": "ğŸš¶",
        "bicycling": "ğŸš²"
    }
    
    # æ™¯ç‚¹ç±»å‹å›¾æ ‡æ˜ å°„
    attraction_icons = {
        "å…¬å›­": "ğŸŒ³", "åšç‰©é¦†": "ğŸ›ï¸", "å¯ºåº™": "ğŸ›•", "å¹¿åœº": "ğŸŸ©", "å±±å³°": "â›°ï¸",
        "æ¹–æ³Š": "ğŸ’§", "å¤è¿¹": "ğŸ¯", "å»ºç­‘": "ğŸ¢", "é…’åº—": "ğŸ¨", "é¤å…": "ğŸ´",
        "å•†åœº": "ğŸ¬", "è½¦ç«™": "ğŸš‰", "æœºåœº": "âœˆï¸", "åŒ»é™¢": "ğŸ¥", "å­¦æ ¡": "ğŸ«",
        "é“¶è¡Œ": "ğŸ¦", "æ•™å ‚": "â›ª", "å¡”": "ğŸ—¼", "æ¡¥": "ğŸŒ‰", "æµ·æ»©": "ğŸ–ï¸"
    }
    
    # ç”ŸæˆHTMLåœ°å›¾
    html_content = f"""
    <div style='position: relative;'>
        <div id="mapContainer" style='width: 100%; height: 600px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);'></div>
        <div id="routeInfo" style='position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 5px; font-size: 14px; max-width: 200px;'></div>
    </div>
    <script src="https://webapi.amap.com/maps?v=2.0&key={AMAP_API_KEY}"></script>
    <script src="https://webapi.amap.com/ui/1.1/main.js"></script>
    <script>
        var map = new AMap.Map('mapContainer', {{
            center: [{center_lng}, {center_lat}],
            zoom: {zoom_level},
            viewMode: '3D'
        }});
        
        // ä½¿ç”¨ç°ä»£åœ°å›¾æ ·å¼
        map.setMapStyle('amap://styles/fresh');
        
        var markers = [];
        var infoWindows = [];
    """
    
    # æ·»åŠ æ™¯ç‚¹æ ‡è®°
    for i, (lng, lat, addr, info) in enumerate(valid_locations):
        # æ ¹æ®æ™¯ç‚¹ç±»å‹é€‰æ‹©å›¾æ ‡
        icon = "ğŸ“"
        poi_type = info.get('type', '')
        for category, emoji in attraction_icons.items():
            if category in poi_type or category in addr:
                icon = emoji
                break
        
        html_content += f"""
        var marker{i} = new AMap.Marker({{
            position: [{lng}, {lat}],
            map: map,
            content: '<div style="font-size: 24px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); cursor: pointer;" title="{addr}">{icon}</div>',
            offset: new AMap.Pixel(-12, -24)
        }});
        
        var infoWindow{i} = new AMap.InfoWindow({{
            content: '<div style="padding: 15px; max-width: 320px; font-family: Arial, sans-serif;">' +
                     '<div style="border-bottom: 2px solid #3366FF; padding-bottom: 8px; margin-bottom: 10px;">' +
                     '<h3 style="margin: 0; color: #333; font-size: 18px;">{icon} {info.get("name", addr)}</h3>' +
                     '</div>' +
                     '<div style="margin-bottom: 8px;"><strong style="color: #666;">ğŸ“ åœ°å€:</strong> <span style="color: #333;">{addr}</span></div>' +
                     '<div style="margin-bottom: 8px;"><strong style="color: #666;">ğŸ·ï¸ ç±»å‹:</strong> <span style="color: #333;">{info.get("type", "æœªçŸ¥")}</span></div>' +
                     {f'<div style="margin-bottom: 8px;"><strong style="color: #666;">ğŸ“ ç”µè¯:</strong> <span style="color: #333;">{info.get("tel", "æš‚æ— ")}</span></div>' if info.get("tel") else ''} +
                     {f'<div style="margin-bottom: 8px;"><strong style="color: #666;">â­ è¯„åˆ†:</strong> <span style="color: #FF6600;">{info.get("rating", "æš‚æ— ")}</span></div>' if info.get("rating") else ''} +
                     {f'<div style="margin-bottom: 8px;"><strong style="color: #666;">ğŸ’° äººå‡:</strong> <span style="color: #333;">{info.get("cost", "æš‚æ— ")}</span></div>' if info.get("cost") else ''} +
                     '<div style="text-align: center; margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">' +
                     '<span style="background: #3366FF; color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px;">æ™¯ç‚¹ #{i+1}</span>' +
                     '</div>' +
                     '</div>',
            offset: new AMap.Pixel(0, -30)
        }});
        
        marker{i}.on('click', function() {{
            infoWindows.forEach(function(window) {{
                window.close();
            }});
            infoWindow{i}.open(map, marker{i}.getPosition());
        }});
        
        markers.push(marker{i});
        infoWindows.push(infoWindow{i});
        """
    
    # æ·»åŠ è·¯çº¿
    if routes and show_details:
        html_content += """
        var polylines = [];
        var routeInfoWindows = [];
        """
        
        for i, route in enumerate(routes):
            if route.get("success") and route.get("polyline"):
                points = route["polyline"].split(';')
                if len(points) > 1:
                    try:
                        path = [[float(p.split(',')[0]), float(p.split(',')[1])] for p in points if ',' in p]
                        if path:
                            # æ ¹æ®äº¤é€šæ–¹å¼è®¾ç½®æ ·å¼
                            transport_styles = {
                                "driving": {"color": "#3366FF", "weight": 6, "opacity": 0.8, "icon": "ğŸš—"},
                                "transit": {"color": "#FF6600", "weight": 5, "opacity": 0.8, "icon": "ğŸšŒ"},
                                "walking": {"color": "#66CC66", "weight": 4, "opacity": 0.8, "icon": "ğŸš¶"},
                                "bicycling": {"color": "#CC66CC", "weight": 5, "opacity": 0.8, "icon": "ğŸš²"}
                            }
                            
                            style = transport_styles.get(route["transport_mode"], transport_styles["driving"])
                            
                            # ä¿®å¤parseInté—®é¢˜ï¼šç¡®ä¿durationæ˜¯æ•°å€¼ç±»å‹
                            duration_seconds = 0
                            try:
                                duration_seconds = parseInt(route.get("duration", "0"));
                            except:
                                duration_seconds = 0;
                                
                            html_content += f"""
                            var polyline{i} = new AMap.Polyline({{
                                path: {path},
                                strokeColor: '{style["color"]}',
                                strokeWeight: {style["weight"]},
                                strokeOpacity: {style["opacity"]},
                                lineJoin: 'round',
                                lineCap: 'round',
                                zIndex: 50,
                                map: map,
                                cursor: 'pointer'
                            }});
                            
                            var routeInfoWindow{i} = new AMap.InfoWindow({{
                                content: '<div style="padding: 15px; max-width: 280px; font-family: Arial, sans-serif;">' +
                                         '<div style="border-bottom: 2px solid {style["color"]}; padding-bottom: 8px; margin-bottom: 10px;">' +
                                         '<h3 style="margin: 0; color: #333; font-size: 16px;">{style["icon"]} è·¯çº¿ {i+1}</h3>' +
                                         '</div>' +
                                         '<div style="margin-bottom: 8px;"><strong style="color: #666;">ğŸš€ äº¤é€šæ–¹å¼:</strong> <span style="color: #333;">{get_transport_name(route["transport_mode"])}</span></div>' +
                                         '<div style="margin-bottom: 8px;"><strong style="color: #666;">ğŸ“ è·ç¦»:</strong> <span style="color: #333; font-weight: bold;">{(parseFloat(route.get("distance", 0))/1000).toFixed(2)} å…¬é‡Œ</span></div>' +
                                         '<div style="margin-bottom: 8px;"><strong style="color: #666;">â±ï¸ é¢„è®¡æ—¶é—´:</strong> <span style="color: #333; font-weight: bold;">{format_duration(duration_seconds)}</span></div>' +
                                         {f'<div style="margin-bottom: 8px;"><strong style="color: #666;">ğŸ’° è¿‡è·¯è´¹:</strong> <span style="color: #FF6600; font-weight: bold;">{route.get("tolls", "0")} å…ƒ</span></div>' if route.get("tolls") and route.get("tolls") != "0" else ''} +
                                         {f'<div style="margin-bottom: 8px;"><strong style="color: #666;">ğŸš¦ çº¢ç»¿ç¯:</strong> <span style="color: #333;">{route.get("traffic_lights", "0")} ä¸ª</span></div>' if route.get("traffic_lights") and route.get("traffic_lights") != "0" else ''} +
                                         '<div style="text-align: center; margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">' +
                                         '<span style="font-size: 12px; color: #999;">ç‚¹å‡»è·¯çº¿æŸ¥çœ‹è¯¦æƒ…</span>' +
                                         '</div>' +
                                         '</div>',
                                offset: new AMap.Pixel(0, -30)
                            }});
                            
                            polyline{i}.on('click', function(e) {{
                                routeInfoWindows.forEach(function(window) {{
                                    window.close();
                                }});
                                routeInfoWindow{i}.open(map, e.lnglat);
                            }});
                            
                            polyline{i}.on('mouseover', function() {{
                                polyline{i}.setOptions({{
                                    strokeWeight: {style["weight"] + 2},
                                    strokeOpacity: 1.0
                                }});
                            }});
                            
                            polyline{i}.on('mouseout', function() {{
                                polyline{i}.setOptions({{
                                    strokeWeight: {style["weight"]},
                                    strokeOpacity: {style["opacity"]}
                                }});
                            }});
                            
                            polylines.push(polyline{i});
                            routeInfoWindows.push(routeInfoWindow{i});
                            """
                    except Exception as e:
                        print(f"è·¯çº¿ {i} ç»˜åˆ¶å¤±è´¥: {e}")
    
    # æ·»åŠ åœ°å›¾æ§ä»¶å’ŒåŠŸèƒ½
    html_content += f"""
        // æ·»åŠ åœ°å›¾æ§ä»¶
        map.addControl(new AMap.ToolBar({{
            position: 'LT'
        }}));
        map.addControl(new AMap.Scale({{
            position: 'LB'
        }}));
        
        // æ·»åŠ è·¯çº¿æ€»è§ˆä¿¡æ¯
        function updateRouteInfo() {{
            var totalDistance = 0;
            var totalDuration = 0;
            var routeCount = 0;
            
            {generate_route_summary_js(routes) if routes else ""}
            
            if (routeCount > 0) {{
                document.getElementById('routeInfo').innerHTML = 
                    '<div style="font-weight: bold; margin-bottom: 5px; color: #333;">ğŸ—ºï¸ è·¯çº¿æ€»è§ˆ</div>' +
                    '<div style="font-size: 12px; color: #666;">ğŸ“ {len(valid_locations)} ä¸ªæ™¯ç‚¹</div>' +
                    '<div style="font-size: 12px; color: #666;">ğŸ›£ï¸ ' + routeCount + ' æ®µè·¯çº¿</div>' +
                    '<div style="font-size: 12px; color: #666;">ğŸ“ æ€»è·ç¦»: ' + (totalDistance/1000).toFixed(2) + ' å…¬é‡Œ</div>' +
                    '<div style="font-size: 12px; color: #666;">â±ï¸ æ€»æ—¶é—´: ' + Math.round(totalDuration/60) + ' åˆ†é’Ÿ</div>';
            }}
        }}
        
        // è‡ªåŠ¨è°ƒæ•´åœ°å›¾è§†é‡
        function fitMapView() {{
            var bounds = new AMap.Bounds();
            markers.forEach(function(marker) {{
                bounds.extend(marker.getPosition());
            }});
            
            if (markers.length > 1) {{
                map.setBounds(bounds, false, [20, 20, 20, 20]);
            }} else if (markers.length === 1) {{
                map.setCenter(markers[0].getPosition());
                map.setZoom(15);
            }}
        }}
        
        // æ·»åŠ åœ°å›¾ç‚¹å‡»äº‹ä»¶ï¼Œå…³é—­æ‰€æœ‰ä¿¡æ¯çª—å£
        map.on('click', function() {{
            infoWindows.forEach(function(window) {{
                window.close();
            }});
            routeInfoWindows.forEach(function(window) {{
                window.close();
            }});
        }});
        
        // åˆå§‹åŒ–
        setTimeout(function() {{
            fitMapView();
            updateRouteInfo();
        }}, 500);
        
        // è¾…åŠ©å‡½æ•°
        function getTransportName(mode) {{
            var names = {{
                'driving': 'è‡ªé©¾',
                'transit': 'å…¬äº¤',
                'walking': 'æ­¥è¡Œ',
                'bicycling': 'éª‘è¡Œ'
            }};
            return names[mode] || mode;
        }}
        
        function formatDuration(seconds) {{
            var hours = Math.floor(seconds / 3600);
            var minutes = Math.floor((seconds % 3600) / 60);
            if (hours > 0) {{
                return hours + 'å°æ—¶' + minutes + 'åˆ†é’Ÿ';
            }} else {{
                return minutes + 'åˆ†é’Ÿ';
            }}
        }}
    </script>
    """
    
    return html_content

def calculate_max_distance(locations):
    """è®¡ç®—åœ°ç‚¹é—´çš„æœ€å¤§è·ç¦»ï¼ˆç”¨äºç¡®å®šç¼©æ”¾çº§åˆ«ï¼‰"""
    max_dist = 0
    for i in range(len(locations)):
        for j in range(i + 1, len(locations)):
            lng1, lat1 = locations[i][0], locations[i][1]
            lng2, lat2 = locations[j][0], locations[j][1]
            dist = math.sqrt((lng2 - lng1)**2 + (lat2 - lat1)**2)
            max_dist = max(max_dist, dist)
    return max_dist

def calculate_zoom_level(max_distance):
    """æ ¹æ®æœ€å¤§è·ç¦»è®¡ç®—åˆé€‚çš„ç¼©æ”¾çº§åˆ«"""
    if max_distance > 5:
        return 6
    elif max_distance > 2:
        return 8
    elif max_distance > 1:
        return 10
    elif max_distance > 0.5:
        return 11
    elif max_distance > 0.1:
        return 13
    else:
        return 15

def generate_route_summary_js(routes):
    """ç”Ÿæˆè·¯çº¿æ‘˜è¦çš„JavaScriptä»£ç """
    if not routes:
        return ""
    
    js_code = ""
    for i, route in enumerate(routes):
        if route.get("success"):
            js_code += f"""
            totalDistance += {route.get('distance', 0)};
            totalDuration += {route.get('duration', 0)};
            routeCount++;
            """
    return js_code

def get_transport_name(transport_mode):
    """è·å–äº¤é€šæ–¹å¼çš„ä¸­æ–‡åç§°"""
    names = {
        "driving": "è‡ªé©¾",
        "transit": "å…¬äº¤",
        "walking": "æ­¥è¡Œ",
        "bicycling": "éª‘è¡Œ"
    }
    return names.get(transport_mode, transport_mode)

def format_duration(seconds):
    """æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º"""
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    if hours > 0:
        return f"{hours}å°æ—¶{minutes}åˆ†é’Ÿ"
    else:
        return f"{minutes}åˆ†é’Ÿ"
